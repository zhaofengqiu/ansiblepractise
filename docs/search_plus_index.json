{"./":{"url":"./","title":"Introduction","keywords":"","body":" ansiblepractice this is a practice for ansible newer ansiblepractise this is a practise for ansible by newer 48c9b85babcb0dad815b408ceb86526e7ff1432f Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 12:38:21 "},"inventory/01静态文件.html":{"url":"inventory/01静态文件.html","title":"01静态文件","keywords":"","body":"静态资产就是一个hosts静态文件，一般都设置为hosts文件。 第一个样例 example.com 192.168.10.123 如果没有写组，那么默认是属于all这个组的 写组 [webserver] 192.168.10.12 www.example.com 连续的主机 192.168.10.[1:10] 可以进行嵌套 [all_server] [all_server:childern] webserver 说明webserver这个组是属于all_server的儿子。这种是ini分格。 进行验证 ansible web_serber -i invenstory.ini --list-hosts 查看ansible的对应组成员 群组的群组 目的就在于两个群组如果有相同的task，那么就可直接用了。 如果定义一个名为django的群组，它包括web和task两个群组 的话，解决这个问题将会非常简单。可以在inventory文件中添加如下内容达到这个目的： [django:children] web task 主机缩写： [web] web[1:20].example.com web-[a-t].example.com 在各自文件中的主机和组变量 全部主机与组变量放在inventory文件是合理的： 可以通过组变量进行统一管理，通过主机变量进行单独管理 但是也有不足，只能支持boolean与字符串 所以需要将组变量放在组文件夹，主机变量放在主机变量文件夹中。 与playbook文件平级或者与inventory文件平级 /home/lorin/playbooks/hosts 在/home/lorin/playbooks/host_vars/* /home/lorin/playbook/group_vars/* 组变量文件夹中的文件就是组变量，而文件名就是[]中的 主机变量文件夹中的文件就是对应的主机变量，而文件名就是主机名 如果选择使用YAML字典，那么访问变量的方式也要跟着改变 变为 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:28:26 "},"inventory/02动态文件.html":{"url":"inventory/02动态文件.html","title":"02动态文件","keywords":"","body":"动态inventory 一个动态inventory脚本必须支持如下两个命令行参数。 --host= --list: l=列出群组 Ansible会按照如下形式调用inventory脚本来获取单台主机的详细信息 主机变量 $./dynamic.py --host=vagrant2 返回结果是一个以名字为变量名、值为变量的json对象 { ＂ansible_ssh_host＂: ＂127.0.0.1＂, ＂ansible_ssh_port＂: 2200, ＂ansible_ssh_user＂: ＂vagrant＂} 群组变量： # 调用方式 $./dynamic.py --list 输出 编写动态脚本 #!/usr/bin/env python # Adapted from Mark Mandel's implementation # https://github.com/ansible/ansible/blob/stable-2.1/contrib/inventory/vagrant.py import argparse import json import paramiko import subprocess import sys def list_running_hosts(): cmd = \"vagrant status --machine-readable\" status = subprocess.check_output(cmd.split()).rstrip() hosts = [] for line in status.split('\\n'): (_, host, key, value) = line.split(',')[:4] if key == 'state' and value == 'running': hosts.append(host) return hosts def get_host_details(host): cmd = \"vagrant ssh-config {}\".format(host) p = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE) config = paramiko.SSHConfig() config.parse(p.stdout) c = config.lookup(host) return {'ansible_host': c['hostname'], 'ansible_port': c['port'], 'ansible_user': c['user'], 'ansible_private_key_file': c['identityfile'][0]} def parse_args(): parser = argparse.ArgumentParser(description=\"Vagrant inventory script\") group = parser.add_mutually_exclusive_group(required=True) group.add_argument('--list', action='store_true') group.add_argument('--host') return parser.parse_args() def main(): args = parse_args() # 获取参数 if args.list: # 如果参数是列表的话 hosts = list_running_hosts() #列表变量 json.dump({'vagrant': hosts}, sys.stdout) else: details = get_host_details(args.host) json.dump(details, sys.stdout) if __name__ == '__main__': main() 将inventory分割到多个文件 只需将所有这些文件放到同一个目录并且配置Ansible使用这 个目录作为inventory即可，Ansible将会处理所有的文件并将结果合并为一个inventory。如下： 目录结构： inventory/hosts inventory/vagrant.py ansible.cfg文件内容 [defaults] inventory=inventory Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:27:38 "},"inventory/03资产选择器.html":{"url":"inventory/03资产选择器.html","title":"03资产选择器","keywords":"","body":"资产选择器，就是运行ansible时，选择运行哪些节点 ansible partten -i inventory.yml -m module -a argement 其中partten就是资产选择器，可以选择组亦可以选择其中的某个节点。 资产选择器中，写了什么partten就要用什么，而不是写解析的东西。 选择一台 选择一组 选择父组的时候，也会把子组写出来。 选择多台 使用匹配符 使用逻辑符 并集 交集 排除 正则表达式 数字范围 hosts: web[:5] 通配符 hosts: w*b Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:27:46 "},"play-book/01playbook配置文件.html":{"url":"play-book/01playbook配置文件.html","title":"01playbook配置文件","keywords":"","body":"play book的配置文件是使用yaml文件写的 一个paly book基本单位是hosts。hosts下面有name与task两部分组成 name 指的是这个hosts是是干什么用的 tasks由一系列小组成。 下面有一个demo的配置文件，就是使用playbook去执行ping命令 hosts: web1 name: play-test tasks: - name: check host connection - ping: 效果 play book单位 常⽤属性 name 属性每个play的名字 hosts 属性, 每个play 涉及的被管理服务器，同ad-hoc 中的资 产选择器 tasks 属性, 每个play 中具体要完成的任务，以列表的形式表达 become 属性，如果需要提权，则加上become 相关属性 become_user 属性, 若提权的话，提权到哪个⽤户上 remote_user属性，指定连接到远程节点的⽤户，就是在远程 服务器上执⾏具体操作的⽤户。若不指定，则默认使⽤当前执 ⾏ ansible Playbook 的⽤户 一个play book中可以有多个play项目，如下,是一个play项目： - name: the first play example hosts: webservers remote_user: root tasks: tasks中任务的多种写法 module_name: name=nginx enabled=true state=started # 多⾏的形式: module_name: name=nginx enabled=true state=started # 多⾏写成字典的形式: name: nginx module_name: enabled: true state: started play book的校验 校验 下⾯校验的⽅法，只能校验PlayBook是否正确，⽽不能校验YAML ⽂件是否语法正确。 ansible-playbook -i hosts myplaybook.yml --syntaxcheck 使用检查yaml的方式，对playbook进行检查 python -c 'import yaml,sys; print yaml.safe_load(sys.stdin)' 单步调试 每次都会执行一个task // 执⾏Task中的任务，需要⼿动确认是否往下执⾏。 ansible-playbook -i hosts myplaybook.yml --step 模拟执行 检测自己的playbook有无语法错误，是不是能够直接执行，只是一个测试方式 ansible-playbook -i hosts myplaybook.yml -C -C 其实应该就是--checkout 调试信息查看 ansible-playbook -i hosts myplaybook.yml -VVV v越多越详细，支持到5个v。执行过程的每一条语句都回输出来。 有个思路就是先限制组再增加日志输出，从而可以定位到报错 ansible-playbook -i hosts checkhosts.yml --limit dbservers -vvv Variables 定义变量 - name: Hello world hosts: web1 vars: greeting: \"hello from vars\" tasks: - name: hello world task debug: msg: \"\" 定义的变量可以在tasks中被引用。 变量也可以定义字典和数组 - name: Hello world hosts: web1 vars: greeting: \"hello from vars\" demo: a: - a: 1 - b: 2 tasks: - name: hello world task debug: msg: \"\" 变量也可以通过外部进行导入变量 - name: Hello world hosts: web1 vars_files: - vars_file/vars/demo.yaml vars: greeting: \"hello from vars\" tasks: - name: hello world task debug: msg: \"\" 这样子的好处就是统一管理变量 变量优先级： 简单的来说就是后面覆盖前面。 两种情况， 变量都在文件中，前面文件中的变量会被后面文件中定义的相同的变量覆盖 外部引用的文件中的变量会被自己文件中后面定义的变量覆盖掉。 group变量与host变量 这里的变量指的是主机变量，比如，主机名、主机密码、主机端口等等。是主机级别的 这里需要一个文件和两个文件夹。 一个文件是host文件，这个文件中，介绍了有多少主机，就和/etc/passwd一样，介绍了有多少个用户，而另外两个文件夹，分别是group文件夹和host文件夹。 源investory文件 内容如下： [web] ansible-node1 ansible-connection=ssh ansible_user=root [db] host1 ansible-connection=ssh ansible_user=root http_port=443 ansible-node3 ansible-connection=ssh ansible_user=root ansible-node4 ansible-connection=ssh ansible_user=root 进行划分 其中host中，只有节点的主机名 [all] ansible-node1 ansible-node2 ansible-node3 ansible-node4 host1 group_vars中包含了分组变量文件，每个文件包含了一个分组的变量，比如上文中的db.yaml. ansible-connection: ssh ansible_user: root host_vars文件中，包含了多个文件，其中的每一个文件代表的都是一台节点机的单独配置，你可以将其单独配置写入其中 http_port ansible.cfg 这个文件是配置文件，我们可以将investory配置文件写入，这样子执行的时候，就不用用参数i去指定路径了。 有三个地方可以寻找这个文件，优先级从前到后i 首先会在执行ansible的当前目录寻找这个文件 会查找环境变量中的ANSIBLE_CONFIG查找这个配置文件 最后才会使用/etc/ansible中的ansible.cfg这个配置文件。 ansible适合放的是ansible级别的变量，比如private-key的目录和username等。 过滤器 默认过滤器 为没有定义内容的变量设置一个变量 ＂HOST＂: ＂localhost＂, 如果变量database_host已被定义，那么直接使用这个值。没被定义，则会设置成localhost这个默认值 文件路径的过滤器 basename过滤器可以让我们从全路径中提取文件名部分 过滤器编写 TODO lookup模块 与系统进行交互，是一个函数，被的jinj2模板所调用 格式统一都是 file 获取系统的相应文件的内容 在playbook中就可以调用key_matrial这个变量获取到对应文件中的密钥信息 pipe 执行一条命令，获取这条命令的结果 env 获取到系统变量 template lookup会让你指定一个Jinja2模板文件，然后返回这个模板渲染的结果. \\ csvfile 获取csv中对应位置的数据 dnstxt 获取对应dns的ip redis_kv include include 获取到的是整个文件 静态引用 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 13:05:37 "},"play-book/02loop循环.html":{"url":"play-book/02loop循环.html","title":"02loop循环","keywords":"","body":"单层循环 - name: Hello world hosts: web1 vars: test: - test1 - test2 - test3 - test4 tasks: - name: hello world task debug: msg: \"\" with_items: \"\" 双层循环 - name: Hello world hosts: web1 vars: test: - test1 - test2 - test3 - test4 demo: - demo1 - demo2 - demo3 - demo4 tasks: - name: hello world task debug: msg: \" \" with_nested: - \"\" - \"\" 注意： debug与with_nested需要在同一层 输出： ok: [ansible-node1] => (item=[u'test1', u'demo1']) => { \"msg\": \"test1 demo1\" } ok: [ansible-node1] => (item=[u'test1', u'demo2']) => { \"msg\": \"test1 demo2\" } ok: [ansible-node1] => (item=[u'test1', u'demo3']) => { \"msg\": \"test1 demo3\" } ok: [ansible-node1] => (item=[u'test1', u'demo4']) => { \"msg\": \"test1 demo4\" } ok: [ansible-node1] => (item=[u'test2', u'demo1']) => { \"msg\": \"test2 demo1\" } ok: [ansible-node1] => (item=[u'test2', u'demo2']) => { \"msg\": \"test2 demo2\" } ok: [ansible-node1] => (item=[u'test2', u'demo3']) => { \"msg\": \"test2 demo3\" } ok: [ansible-node1] => (item=[u'test2', u'demo4']) => { \"msg\": \"test2 demo4\" } ok: [ansible-node1] => (item=[u'test3', u'demo1']) => { \"msg\": \"test3 demo1\" } ok: [ansible-node1] => (item=[u'test3', u'demo2']) => { \"msg\": \"test3 demo2\" } ok: [ansible-node1] => (item=[u'test3', u'demo3']) => { \"msg\": \"test3 demo3\" } ok: [ansible-node1] => (item=[u'test3', u'demo4']) => { \"msg\": \"test3 demo4\" } ok: [ansible-node1] => (item=[u'test4', u'demo1']) => { \"msg\": \"test4 demo1\" } ok: [ansible-node1] => (item=[u'test4', u'demo2']) => { \"msg\": \"test4 demo2\" } ok: [ansible-node1] => (item=[u'test4', u'demo3']) => { \"msg\": \"test4 demo3\" } ok: [ansible-node1] => (item=[u'test4', u'demo4']) => { \"msg\": \"test4 demo4\" } item[0] 对with_nested数组的第一个元素。 也可以将with_nested放置到上面，只要与debug同层即可。这样子，debug执行item循环的时候，就会自动去读取。但是为了方便，下面的条件判断的时候。 tasks: - name: hello world task with_nested: - \"\" - \"\" debug: msg: \" \" 三层循环 一样的，只要在with_nested中增加一个元素即可 tasks: - name: hello world task with_nested: - \"\" - \"\" - \"\" debug: msg: \" \" 更复杂的循环 with_lines 对文件内容进行迭代 - name: send out a slack message slack: domain: example/slack.com token: \"\" msg:\" was in the list\" with_lines: - cat files/turing.txt 上面的task就是如何使用with_lines读取文件并逐行迭代它的内容。 with_dict with_dict结构可以让你对字典而非列表进行迭代。当使用这种循环结构的时候，item 循环变量是一个有两个键的字典： 对下面这个字典进行迭代 - name: iterate over ansible_eth0 debug: msg== with_dict: \"\" 输出如下： 设置变量名称 迭代变量默认名是item，使用loop_var可以为迭代变量指定其他名字，通过loop_control - user: name: \"\" with_items: - {name:fil} - {name: sarina} - {name: leanne} loop_control: loop_var: user user指代的是一个字典 迭代 --name: install apt aptL okg= update_cache=True become: True with_items: - git - nginx ... 默认情况下，Ansible总是使用item作为循环迭代变量的名字。在第8章中，我们将演 示如何更改这个变量的名称。 传递字典 - name: python packages pip:> name= version= virtualenv= with_items: - {name: mezzanine, version: 4.2} - {name: gunicorn, version: 1.4.2} - {name: django-compressor, version: 2.1} Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:29:38 "},"play-book/03条件语句.html":{"url":"play-book/03条件语句.html","title":"03条件语句","keywords":"","body":"可以通过条件语句，去进行条件判断，从而决定要不要执行这个task。 单个判断 - name: Hello world hosts: web1 vars: test: - test1 - test2 - test3 - test4 tasks: - name: hello world task debug: msg: \"\" with_items: \"\" when item>=3: 两个条件 and tasks: - name: Shut down CentOS 6 systems ansible.builtin.command: /sbin/shutdown -t now when: - ansible_facts['distribution'] == \"CentOS\" - ansible_facts['distribution_major_version'] == \"6\" 两个条件 or状态 tasks: - name: Shut down CentOS 6 and Debian 7 systems ansible.builtin.command: /sbin/shutdown -t now when: (ansible_facts['distribution'] == \"CentOS\" and ansible_facts['distribution_major_version'] == \"6\") or (ansible_facts['distribution'] == \"Debian\" and ansible_facts['distribution_major_version'] == \"7\") Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-23 14:24:22 "},"play-book/04set_fact变量.html":{"url":"play-book/04set_fact变量.html","title":"04set_fact变量","keywords":"","body":"set_fact 关键字 task中的单位是单个主机。 yaml的文件内部支持jinj2这种模板语言，使用方式\"\" set_fact 模块，这个模块就是作为变量赋值用的 - name: test facts hosts: web1 gather_facts: no tasks: - debug: var: hostvars[ansible_host] 其中的基本单位就是以主机为单位，进行循环遍历 - name: test facts hosts: all gather_facts: yes tasks: - debug: var: hostvars[ansible_host]['ansible_nodename'] set_fact 设置变量 - name: test facts hosts: all gather_facts: yes tasks: - name: test set facts set_fact: test_set_fact: \"set from set_fact \" - debug: var: hostvars[ansible_host]['test_set_fact'] 设置后，直接就可以从ansible_host读取出来。 如何实现，执行了command命令以后，将结果保存到fact中 - name: test facts hosts: all gather_facts: yes tasks: - name: command command: cat /etc/hosts register: host_results - name: set host results set_fact: hosts_ip: \"\" - debug: var: hosts_ip 从这个例子中，也可以看出来只要涉及到变量，那么就需要使用Jinj2模板语言。 ansible 的fact会收集主机的各种详细信息，这些信息存储在facts变量中。ansible 收集fact会自动收集，但如果需要命令行收集，那么就需要增加setup参数 ansible server1 -m setup fact非常非常多，可以使用匹配符去匹配key。 ansible web -m setup -a \"filter=ansible_eth*\" 一个问题？为什么能够直接使用fact收集的变量？ 因为如果模块返回一个字典且其中包含 ansible_facts键，那么Ansible会为对应主机创建相应的变量。会将ansible_facts对应值中的所有键都创建变量。因此可以直接使用这些ansible_facts中的变量名 使用set fact定义新变量 内置变量 hostvars inventory hostname groups 在命令行设置变量 优先级 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:30:14 "},"play-book/05block异常捕获.html":{"url":"play-book/05block异常捕获.html","title":"05block异常捕获","keywords":"","body":"通过block进行task的异常捕获 --- - name: test block hosts: all tasks: - block: - name: debug before task failed debug: msg: \"I execute normally\" - name: failure command: /bin/echo rescue: - name: test rescue debug: msg: \"I never execute, as above task is failing...\" always: - name: always debug debug: msg: \"this always executes\" when: ansible_facts['distribution'] == \"CentOS\" 等价于 --- - name: test block hosts: all tasks: rey: - name: debug before task failed debug: msg: \"I execute normally\" - name: failure command: /bin/echo expect: - name: test rescue debug: msg: \"I never execute, as above task is failing...\" finally: - name: always debug debug: msg: \"this always executes\" when: ansible_facts['distribution'] == \"CentOS\" Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 00:01:26 "},"变量/01ansible全局变量.html":{"url":"变量/01ansible全局变量.html","title":"01ansible全局变量","keywords":"","body":"在命令行中输入进去的,在命令行进行输入的的变量,使用-e参数 key=value 的形式 ansible all -i localhost, -m debug -a \"msg='my key is {{ key }}'\" -e \"key=value\" yaml格式 # cat a.yml --- name: qfedu type: school ansible all -i localhost, -m debug -a \"msg='name is {{ name }}, type is {{ type }}'\" -e @a.yml json格式 # cat a.json {\"name\":\"qfedu\",\"type\":\"school\"} ansible all -i localhost, -m debug -a \"msg='name is , type is '\" -e @a.json 后面两种格式都要使用@符号连接文件 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 16:36:10 "},"变量/02ansible之playbook变量.html":{"url":"变量/02ansible之playbook变量.html","title":"02ansible之playbook变量","keywords":"","body":"定义变量 定义方式： vars属性进行定义 与hosts同一级别 - name: Hello world hosts: web1 vars: greeting: \"hello from vars\" tasks: ... 外部引入变量 - name: test play var from file hosts: all var_file: - vars/users.yml tasks: ... 使用变量 使用Jinj2模板语言，进行引用，使用大括号与双引号。 为什么需要使用双引号？ 这样错误的主要原因是PlayBook 是YAML 的⽂件格式， 当Ansible 分析YAML ⽂件时，有可能会误认为字典。 name: 是⼀个字典的开始。因此加针对变量的使⽤，加 上了双引号，避免Ansible错误解析。 - name: Hello world hosts: web1 vars_files: - vars_file/vars/demo.yaml vars: greeting: \"hello from vars\" tasks: - name: hello world task debug: msg: \"\" 定义的变量可以在tasks中被引用。 变量也可以定义字典和数组 - name: Hello world hosts: web1 vars: greeting: \"hello from vars\" demo: a: - a: 1 - b: 2 tasks: - name: hello world task debug: msg: \"\" 变量也可以通过外部进行导入变量 - name: Hello world hosts: web1 vars_files: - vars_file/vars/demo.yaml vars: greeting: \"hello from vars\" tasks: - name: hello world task debug: msg: \"\" 这样子的好处就是统一管理变量 变量优先级： 简单的来说就是后面覆盖前面。 两种情况， 变量都在文件中，前面文件中的变量会被后面文件中定义的相同的变量覆盖 外部引用的文件中的变量会被自己文件中后面定义的变量覆盖掉。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 16:42:54 "},"变量/03ansible之inventory变量.html":{"url":"变量/03ansible之inventory变量.html","title":"03ansible之inventory变量","keywords":"","body":"分为动态inventory变量与静态inventory变量 inventory静态变量 主机变量 在inventory文件中跟在主机名后 [webserver] 172.18.0.3 user=lilei port=3309 172.18.0.4 user=lilei port=3309 example.com user=lilei port=3309 其中user与port就是静态变量 组变量 我们可以在inventory文件中统一设置变量，这样子就不用将变量进行单一设置，上面的静态变量可以写成下面的组变量 [webserver] 172.18.0.3 172.18.0.4 example.com [webserver:var] user=lilei port=3309 主机组变量与主机变量冲突 那么优先以主机变量为准。原理就和编程中的局部变量与全局变量类似，函数中的局部变量优先级更高。 变量的继承 # cat hosts_v3 [webservers] 172.18.0.3 [dbservers] 172.18.0.4 [allservers] [allservers:children] dbservers webservers [allservers:vars] user=lilei 在资产继承的同时，对应的变量也发⽣了继承 # ansible allservers -i hosts_v3 -m debug -a \"var=user\" 172.18.0.4 | SUCCESS => { \"user\": \"lilei\" } 172.18.0.3 | SUCCESS => { \"user\": \"lilei\" } # ansible dbservers -i hosts_v3 -m debug -a \"var=user\" 172.18.0.4 | SUCCESS => { \"user\": \"lilei\" } # ansible webservers -i hosts_v3 -m debug -a \"var=user\" 172.18.0.3 | SUCCESS => { \"user\": \"lilei\" } 内置变量 ansible_ssh_host 将要连接的远程主机名与你想要设定的主机的别名不同的话,可通过此变量设置. ansible_ssh_port ssh端⼝号.如果不是默认的端⼝号,通过此变量设置. ansible_ssh_user 默认的 ssh ⽤户名 ansible_ssh_pass ssh 密码(这种⽅式并不安全,官⽅强烈建议使⽤ --askpass 或 SSH 密钥) ansible_sudo_pass sudo 密码(这种⽅式并不安全,官⽅强烈建议使⽤ --asksudo-pass) ansible_sudo_exe (new in version 1.8) sudo 命令路径(适⽤于1.8及以上版本) ansible_ssh_private_key_file ssh 使⽤的私钥⽂件.适⽤于有多个密钥,⽽你不想使⽤ SSH代理的情况. ansible_python_interpreter ⽬标主机的 python 路径.适⽤于的情况: 系统中有多个Python, 或者命令路径不是\"/usr/bin/python\",⽐如/usr/local/bin/python3 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 16:57:06 "},"变量/04ansible之fact变量.html":{"url":"变量/04ansible之fact变量.html","title":"04ansible之fact变量","keywords":"","body":"默认情况下，在执⾏PlayBook的时候，它会去⾃动的获取每台被 管理服务器的facts信息。若在整个PlayBook 的执⾏过程中，完全未使⽤过 Facts 变量，此 时我们可以将其关闭，以加快PlayBook的执⾏速度。 - name: a play example hosts: webservers # 关闭 facts 变量收集功能 gather_facts: no ... facts变量的使用 可以像使用其他变量一样，直接在playbook文件中使用 如下： - name: print facts variable hosts: all gather_facts: yes tasks: - name: print facts variable debug: msg: \"The default IPV4 address is \" 直接套用变量,即可获得数据 如何获得数组中的数据？如何获得其他数据?那就通过JinJ2模板语言进行操作。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 17:15:48 "},"变量/05ansible之register变量.html":{"url":"变量/05ansible之register变量.html","title":"05ansible之register变量","keywords":"","body":"往往⽤于保存⼀个task任务的执⾏结果, 以便于debug时使⽤。 或者将此次task任务的结果作为条件，去判断是否去执⾏其他task 任务。 注册变量在PlayBook中通过register关键字去实现。 - name: install a package and print the result hosts: webservers remote_user: root tasks: - name: install nginx package yum: name=nginx state=present register: install_result 执行完这个task后，会将数据注册到install_result这个变量中。后面如果要使用变量，那么直接用这个install_result变量即可。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 17:25:44 "},"变量/06ansible之变量优先级.html":{"url":"变量/06ansible之变量优先级.html","title":"06ansible之变量优先级","keywords":"","body":"变量优先级结论 当⼀个变量同时在全局变量、剧本变量和资产变量中定义时，优先 级最⾼的是全局变量；其次是剧本变量；最后才是资产变量。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 17:32:50 "},"Role/01role的基本使用.html":{"url":"Role/01role的基本使用.html","title":"01role的基本使用","keywords":"","body":"role的作用是编程语言中的模块。模块化编程可以降低代码的编写，我们可以把一些函数放到模块中，通过role可以使得playbook结构更加简单。 role其实就是将一些task划分出去，在外部引用关键字，从而实现task的复用。创建role就是在roles文件夹中创建相应role的文件夹。一个role文件的放置位置 roles/module_name/tasks/main.yml 在外部play-book中，只要在tasks下进行相应的role引入进来。 tasks: - incloud_role: name:install_python - include_role: name:deploy-code 由于引入是写死的，所以我们设置role的目录结构也必须写死。 roles/module_name/tasks/main.yml 只有如上的role文件才能在tasks中引入。 我们可以按照不同的模块进行role的划分，比如安装python的task都放到roles/install-python文件夹中。将task划分出去 那么能够引入一个role中的一个模块的部分task嘛？ Ansible到哪里查找我的role Ansible将会到与你的playbook并列的roles目录下寻找role。 也会在在/etc/ansible/roles中查找系统级的role。 # 文件组成: # task文件 roles/module_name/tasks/main.yml # 上传到主机的文件，这样子就不用考虑roles如果需要文件那应该放在哪里了 # 模板文件 roles/module_name/templates # handler文件 roles/database/handlers/main.yml # 不应该被覆盖的变量 roles/database/vars/main.yml # 可以被覆盖的默认变量 roles/database/defaults/main.yml # role的从属信息 roles/database/meta/main.yml 如何引用 在tasks下的列表中使用即可 第一种方式，当使用role的时候，需要在playbook中增加一个roles区段。roles区段需要列出一个所 使用role的列表。在我们的范例中，这个列表中包括两个role:database和mezzanine。 - name: deplay mezzanine on vagraant vars_files: - secrets.yml roles: - role: database database_name: \"\" 第二种方式，就是在外部play-book中，只要在tasks下进行相应的role引入进来。 tasks: - incloud_role: name:install_python - include_role: name:deploy-code 对于第一种方式，我们需要考虑在调用你的role之前或者之后运行一些task。因此，使用pre-tasks和post-tasks部分 - name: deplay mezzanine on vagraant vars_files: - secrets.yml pre_tasks: - name: update the apt cache apt: update_cache=yes roles: - role: database database_name: \"\" post_tasks: - name: notify slack that servers have been updated local_action:> slack domaon=acme.slack.com ... 从属roles dependencies: -{ role: ntp,ntp_server=ntp.ubuntu.com } 根据ansible的特性，当定义一个role的时候，可以指定他依赖一个或者多个其他role，ansible将会确保被指定为从属的role一定会被先执行。执行完之后，再执行本role。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:30:32 "},"Role/02role文件夹下的子目录介绍.html":{"url":"Role/02role文件夹下的子目录介绍.html","title":"02role文件夹下的子目录介绍","keywords":"","body":"tasks文件夹 这个文件夹就是role中模块出来的文件夹，其中有一个main.yml文件，这个文件就是外部引用role模块时候导入的tasks任务，而这个main.yml文件也可以进行task的进一步模块化。从而使得结构目录更加清除。 假设这个目录是安装python的role。那么就可以再分为两部分安装python所需要的依赖，以及安装python这两块。而main.yml文件只要对这个文件进行汇总即可，从而实现了代码的进一步结构化 # main.yml文件内容 - incloud: yum.yml pip.yml vars文件夹 存储属于这个role模块的变量，只要在这个文件夹中编写一个main.yml文件。将变量写入进去，从而可以直接在/tasks文件夹中进行引用，如下： # vars/main.yml文件内容 repo_url: https://github/com/xiaopeng163、flask-ansible_demo # tasks/main.yml文件内容 - name: checkout sourcec code from github: git: repo: \"\" dest: ~/flask-ansibsle-demo defaults文件夹 用来存放一些默认的变量 files 文件夹 用来存放一些文件，可以被当前的tasks文件夹中的任务直接使用，这样子就不用在考虑task所需要的文件应该存放在哪里了。 template文件夹 用来存放一些Jinj2模板文件，与files文件夹含义相同。template可以直接引用defaults文件夹与vars文件夹中的变量 handlers文件夹 放置的是一个ansible的完整的task。在main.yml文件中使用notify关键字去告诉handle，该执行你这个handle了，但是需要注意的是，如果目标没有发生改变，那么task是不会执行的，对应的，notify关键字也是没有用的。而handles文件夹中也是有一个main.yml文件只会执行这个文件。而这一点与python其实上是一样的，如果py文件没有main函数，那么外部引用的时候也不会执行这个py文件，只会调用文件中的某些函数。 handles的作用： 通知服务的重启，因为目标发生改变了，那么这个task必然会被执行。 handles也可以定义在play-book文件中，只要和tasks同级即可。 # 一个play-book文件，如何调用handler中的task --- - hosts: test remote_user: dwchensenwen become: yes become_method: sudo tasks: - name: make file task1 file: path=/data/task1.txt state=touch notify: task1 - name: make file task2 file: path=/data/task2.txt state=touch notify: task2 handlers: - name: task1 file: path=/data/1.txt state: touch - name: task2 file: path=/data/2.txt state: touch ansible项目目录 现在添加了role模块，那么目录变成了什么样子 ---module_demo |---flask_demo | |---main.yml | |---inventory | | |---group_var | | | |---all.yml | | |---host_var | | | |---host1.yml | | |---hosts |---roles |---deplay_role |---tasks |---defaults |----vats |---files |---handlers Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 11:06:48 "},"Role/03使用ansible-galaxy初始化Role.html":{"url":"Role/03使用ansible-galaxy初始化Role.html","title":"03使用ansible-galaxy初始化Role","keywords":"","body":"是从 ansible2.9版本开始有的。 我们可以使用ansible-galaxy去自动管理role模块 初始化role # 进入指定目录初始化 cd roles ansible-galaxy role init ansible_galaxy_demo ] 从github下载role 模仿python，在项目中有一个类似requirement.txt文件，这个文件是requirement.yml。我们在这个文件中课可以设置我们所需要的role. roles: - src: https://github.com/xiaopeng163/ansible-galaxy-demo scm:git version: master 使用命令 ansible install -r requirements.yml 这个roles会像python一样，将role安装到ansible的安装目录。从这里看，role就很向python的模块，因为可以安装role也可以删除role。 galaxy库 ansible也像python一样有一个共享的role库。 https://galaxy.ansible.com/home 如何从这个库中安装role ansible-galaxy install xiaopeng163.ansible_galaxy_demmo xiaopeng163是namespace，也就是一个用户的空间 ansible_galaxy_demmo也就是我们需要安装的role模块 通过以上两部分，我们就可以成功的定位到一个role模块。 引用从galaxy库的role 我们安装好之后，就需要引用这个role，如何引用，与前面无区别，只要修改一下name即可 tasks: - name: xiaopeng163.ansible_galaxy_demmo 这里的role名称就是我们安装role时候输入的。 requirement.yml 如果从库中安装role，那么requirement.yml怎么写,如下 roles: - src: xiaopeng163.ansible_galaxy_demo version: master Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 11:35:46 "},"ansible逻辑控制/01简介.html":{"url":"ansible逻辑控制/01简介.html","title":"01简介","keywords":"","body":"任务控制类似于编程语⾔中的if ... 、for ... 等逻辑控制语句。 这⾥我们给出⼀个实际场景应⽤案例去说明在PlayBook中，任务 控制如何应⽤。 在下⾯的PlayBook中 我们创建了 tomcat、www 和 mysql 三个 ⽤户。 安装了Nginx 软件包、并同时更新了 Nginx 主配置⽂件和虚拟 主机配置⽂件，最后让Nginx 服务处于启动状态。 上述过程中的创建用户是重复的、是否可以简化？ 上述过程中如果有一个task发生问题、是不是会导致整个出错？ 上述过程中，如果一个task出现错误，是否有补救措施? Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 17:37:50 "},"ansible逻辑控制/02逻辑控制之循环.html":{"url":"ansible逻辑控制/02逻辑控制之循环.html","title":"02逻辑控制之循环","keywords":"","body":"解决第一个问题中的重复task任务。 在PlayBook中使⽤with_items 去实现循环控制，且循环时的中间变量只能是关键字 item ，⽽不能随意 ⾃定义。 - name: variable playbook example hosts: webservers gather_facts: no vars: createuser: - tomcat - www - mysql num: - 1 - 2 - 3 tasks: - name: create user user: name= state=present with_items: \"\" ... - name: show user debug: var: \"\" loop: \"\" when: item 可以看到with_items这个级别与user是同一个级别的。同时这个item是个关键字，所以不需要进行双引号括号。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 18:09:52 "},"ansible逻辑控制/03逻辑控制之判断.html":{"url":"ansible逻辑控制/03逻辑控制之判断.html","title":"03逻辑控制之判断","keywords":"","body":"解决第二个问题 Nginx启动逻辑⽋缺考虑。 若Nginx的配置⽂件语法错误则会导致 启动Nginx失败，以⾄于PlayBook执⾏失败。 如果我们能够在启动之前去对Nginx的配置⽂件语法做正确性的校 验，只有当校验通过的时候我们才去启动或者重启Nginx；否则则跳过 启动Nginx的过程。这样就会避免Nginx 配置⽂件语法问题⽽导致的⽆ 法启动Nginx的⻛险。 - name: task control playbook example hosts: webservers gather_facts: no - name: check nginx syntax shell: /usr/sbin/nginx -t register: nginxsyntax - name: print nginx syntax debug: var=nginxsyntax - name: start nginx server service: name=nginx state=started when: nginxsyntax.rc == 0 when支持的运算符 符号 含义 == 等于 != 不等于 > >= 大于或者大于等于 is defined 是被定义的 is not defined 没有被定义 true boolean false boolean 支持的逻辑运算符 and or Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 17:59:44 "},"ansible逻辑控制/04逻辑运算之tags.html":{"url":"ansible逻辑控制/04逻辑运算之tags.html","title":"04逻辑运算之tags","keywords":"","body":"我们执行一个playbook的时候，只想要执行其中的某些task，那么我们只要给这个playbook中的task增加标签即可。 - hosts: test70 remote_user: root tasks: - name: task1 file: path: /testdir/t1 state: touch tags: t1 - name: task2 file: path=/testdir/t2 state=touch tags: t2 - name: task3 file: path=/testdir/t3 state=touch tags: t3 执行 ansible-playbook --tags=t2 testtag.yml 我们可以使用 --skip-tags选项指定\"不执行的任务\"，执行上述命令后，task1和task3会执行，task2不会执行，因为我们已经在命令中指定了'跳过'标签t2所对应的任务，相当于使用了'排除法'，t2对应的任务被排除了，其他任务都会执行。 之前描述的三种语法都可以指定标签，不过上例中，每个任务只有一个标签，其实，我们可以为每个任务添加多个标签，三种语法添加多个标签的示例如下 语法一： tags: - testtag - t1 语法二： tags: tag1,t1 语法三： tags: ['tagtest','t2'] 上述示例的语法一使用了YAML块序列的语法格式指定多个标签，语法二与语法三都是在原来语法的基础上，使用'逗号'隔开多个标签。 参考文章 http://www.zsythink.net/archives/2641 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 18:07:44 "},"ansible逻辑控制/05逻辑运算之handlers.html":{"url":"ansible逻辑控制/05逻辑运算之handlers.html","title":"05逻辑运算之handlers","keywords":"","body":"观察当前的 Playbook，不能发现，当我的配置⽂件没有发⽣变化 时，每次依然都会去触发TASK \"reload nginx server\"。 如何能做到只有配置⽂件发⽣变化的时候才去触发TASK \"reload nginx server\"，这样的处理才是最完美的实现。此时可以使⽤ handlers 属性。 - name: handlers playbook example hosts: webservers gather_facts: no tasks: - name: update nginx main config copy: src=nginx.conf dest=/etc/nginx/ tags: updateconfig notify: reload nginx server handlers: - name: reload nginx server service: name=nginx state=reloaded when: - nginxsyntax.rc == 0 - nginxrunning.stat.exists == true 问题就是，程序怎么知道它并没有发生改变？ Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 18:17:58 "},"模块/Commands模块.html":{"url":"模块/Commands模块.html","title":"Commands模块","keywords":"","body":" command模块 目标机器上去执行一个命令，不涉及环境变量与操作符 shell模块 目标机器上去执行一个shell命令 raw模块 这个模块可以控制华为、思科的路由器，只要这两者支持ssh。 command模块 - name: command module hosts: all become: yes tasks: - name: tset command command: cat /etc/hosts 但是，这个是没有响应的，因此，我们需要的是响应。 所有的模块都是由返回值的，我们通过返回值就可以知道执行的结果了。下面介绍了如何在play-book查看返回值，会返回一个json的数据结构。 - name: command module hosts: all become: yes tasks: - name: tset command command: cat /etc/hosts # 将返回值赋值给变量 register: hosts_values - debug: msg: \"\" 不同的模块会有一些常见的返回值。我们可以通过字典的形式去获取内容。 shell命令 shell命令 可以跟上一条命令，对所有的节点执行这条命令 shell是可以允许管道符的 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 14:41:12 "},"模块/debug模块.html":{"url":"模块/debug模块.html","title":"debug模块","keywords":"","body":"debug模块 - name: Hello world hosts: web1 tasks: - name: hello world task debug: msg: \"hello world\" 可以看到 hello world task 这个task被执行了。 verbosity代表的是debug级别，调高后，就不会显示出来。默认是0 - name: Hello world hosts: web1 tasks: - name: hello world task debug: msg: \"hello world\" verbosity: 3 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-23 11:06:54 "},"模块/包管理之apt.html":{"url":"模块/包管理之apt.html","title":"包管理之apt","keywords":"","body":"安装 # 安装软件 - name: Install apache httpd (state=present is optional) apt: name: apache2 state: present # 更新软件 - name: Update repositories cache and install \"foo\" package apt: name: foo update_cache: yes # 删除ruan0j - name: Remove \"foo\" package apt: name: foo state: absent # 安装列表 - name: Install a list of packages apt: pkg: - foo - foo-tools # 指定版本 - name: Install the version '1.00' of package \"foo\" apt: name: foo=1.00 - name: Update the repository cache and update package \"nginx\" to latest version using default release squeeze-backport apt: name: nginx state: latest default_release: squeeze-backports update_cache: yes - name: Install latest version of \"openjdk-6-jdk\" ignoring \"install-recommends\" apt: name: openjdk-6-jdk state: latest install_recommends: no - name: Update all packages to their latest version apt: name: \"*\" state: latest - name: Upgrade the OS (apt-get dist-upgrade) apt: upgrade: dist - name: Run the equivalent of \"apt-get update\" as a separate step apt: update_cache: yes - name: Only run \"update_cache=yes\" if the last one is more than 3600 seconds ago apt: update_cache: yes cache_valid_time: 3600 - name: Pass options to dpkg on run apt: upgrade: dist update_cache: yes dpkg_options: 'force-confold,force-confdef' - name: Install a .deb package apt: deb: /tmp/mypackage.deb - name: Install the build dependencies for package \"foo\" apt: pkg: foo state: build-dep - name: Install a .deb package from the internet apt: deb: https://example.com/python-ppq_0.1-1_all.deb - name: Remove useless packages from the cache apt: autoclean: yes - name: Remove dependencies that are no longer required apt: autoremove: yes 如何进行过滤 由于系统有ubuntu系统与centos系统，所以我们可以通过when去进行过滤 - name: Install apache Ubuntu apt: name: apache2 state: present when: ansible_facts['distribution']=='Ubuntu' - name: Install apache httpd CentOS yum: name: apache2 state: present when: ansible_facts['distribution']=='CentOS' Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 03:11:32 "},"模块/包管理之pip.html":{"url":"模块/包管理之pip.html","title":"包管理之pip","keywords":"","body":"使用虚拟环境 使用虚拟环境进行安装软件 - name: pip install flask pip: name: flask state: present virtualenv: /home/vagrant/vir/ virtualenv_command: /usr/bin/python3 -m venv 首先创建一个虚拟环境，创建好之后再进行flask的安装 先执行virtualenv与virtualenv_command再执行安装flask。 pip需要注意的就是如何使用ansible中的pipi模块进行虚拟环境的安装。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 10:08:32 "},"模块/包管理之yum.html":{"url":"模块/包管理之yum.html","title":"包管理之yum","keywords":"","body":"统一安装软件 参数： name:代表包的名称 state: present 和installed 是直接安装软件 latest 确保安装的软件是最新的 remove 和absent是删除软件包 - name: file module hosts: web1 tasks: - name: test the package yum: name: git state: present 一次性安装多个软件 # 通过列表 - name: Install a list of packages (suitable replacement for 2.11 loop deprecation warning) yum: name: - nginx - postgresql - postgresql-server state: present # 通过变量循环 - name: Install a list of packages with a list variable yum: name: \"\" vars: packages: - httpd - httpd-tools # 直接下载url进行安装 - name: Install the nginx rpm from a remote repo yum: name: http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm state: present - name: Install nginx rpm from a local file yum: name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm state: present Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 03:04:26 "},"模块/包管理之包管理.html":{"url":"模块/包管理之包管理.html","title":"包管理之包管理","keywords":"","body":"service管理 包安装好之后，我们需要进行服务开启，比如安装好apache2，那么我们就需要进行apache2服务的开启。 - name: install and start nginx hosts: all tasks: - name: install nginx on centos become: yes yum: name: - epel-release - nginx state: present use_proxy: yes when: ansible_facts['distribution'] == \"CentOS\" - name: Start service nginx become: yes service: name: nginx state: stopped 其他的选项： state: started restarted stoped 除了service软件管理，还有systemctl模块对软件可以进行管理。 systemd centos7就开始使用systemctl进行管理软件了。 常见参数： daemon_reload 重新载入systemd、扫描新的或者有变动单元 enabled 是否开启启动该服务 name 服务名称，需要管理的服务 state 对对当前服务 执行started、stopped、restarted、reloaded操作 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 14:46:52 "},"模块/文件模块之copy-file.html":{"url":"模块/文件模块之copy-file.html","title":"文件模块之copy-file","keywords":"","body":"copy模块只是做文件的复制，不能创建目录 而copy则可以删除文件，创建文件夹 file模块 copy之前，需要对文件夹进行创建，保证文件夹已经创建成功 - name: file module hosts: all gather_facts: no become: yes tasks: - name: Create a directory if it does not exist file: path: /etc/test state: directory 其中 become是进行提权 copy模块 可以对文件进行备份 - name: file module hosts: all gather_facts: no become: yes tasks: - name: Create a directory if it does not exist file: path: /etc/test state: directory - name: copy files from local to remote copy: src: files/test.txt dest: /etc/test/test.txt backup: yes backup 是备份，防止原文件被覆盖，这样子原来的文件就会以备份的形式加上一个时间戳保留下来。 copy模块，还可以指定文件的用户名和所在组 - name: copy files from local to remote copy: src: files/test.txt dest: /etc/test/test.txt ower: auser group: auser backup: yes 前提是这个文件名和所在组必须是存在与系统中，不然就会报错 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 01:35:16 "},"模块/文件模块之fetch.html":{"url":"模块/文件模块之fetch.html","title":"文件模块之fetch","keywords":"","body":"fetch模块 fetch模块就是从远端拉取文件到本地 - name: fetch a file fetch: src: 远端的文件 dst: 本地的文件 如果本地没有这个目录。那么fetch模块就会自动创建出来，如果下拉的是文件夹，那么就会把整个文件夹拉下来。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 23:48:22 "},"模块/文件模块之template.html":{"url":"模块/文件模块之template.html","title":"文件模块之template","keywords":"","body":"​ 这个模块，作用就是定义一个模板，然后把这个模板下发到各个控制节点。从而实现一台控制器，下发多个配置文件。 首先，从前面可以知道，只要遵循目录架构，那么就可以实现将所有的group变量与host变量从group_vars与host_vars中读取出来。所以在site.yml中可以直接使用这些变量，而不需要进行引用。 这里我一直经历了这个报错，\"Could not find or access 'template/test.txt'\\nSearched，后面才发现是自己的文件路径写错了，从而导致不能找到。 - name: test template template: src: template/test.j2 dest: /etc/test/test.cfg 其中的test.j2内容如下 [default] http_port= j2其实是使用了jinj2这个模板语言。 查看内容，已经成功被修改 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 02:09:26 "},"模块/文件模块之文件内容.html":{"url":"模块/文件模块之文件内容.html","title":"文件模块之文件内容","keywords":"","body":"lineinfile模块 这个模块是在被管理节点上，用正则匹配的方式对目标文件的一行修改内容进行删除修改等操作。 blockin line 对文件中的多行进行一次性添加、更新和删除等操作 replace 把文件中正则匹配到的多行进行进行统一处理 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 15:36:36 "},"模块/系统模块之用户与组.html":{"url":"模块/系统模块之用户与组.html","title":"系统模块之用户与组","keywords":"","body":"group group模块只有一个必填的参数就是名字 增加group - name: file module hosts: web1 tasks: - name: create group group: name: ansible_demo_wjs 结果查看 删除group 这个就需要增加一个参数，state:absent 用来表示删除 - name: file module hosts: web1 tasks: - name: create group group: name: ansible_demo_wjs state: absent user 新增用户 - name: file module hosts: web1 tasks: - name: create group user: name: ansible_demo_user 为用户设置密码 结果展示 删除用户 - name: file module hosts: web1 tasks: - name: create group user: name: ansible_demo_user state: absent remove: yes # 将创建的用户的目录一起删除掉 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 12:03:32 "},"模块/网络模块之get_url.html":{"url":"模块/网络模块之get_url.html","title":"网络模块之get_url","keywords":"","body":"- name: net-tools module hosts: web1 become: yes tasks: - name: test get_url get_url: url: https://www.python.org/ftp/python/3.9.0/python390.chm dest: /etc/test/ checksum: md5:9ea6fc676f0fa3b95af3c5b3400120d6 - name: 进行解压 unarchive: src: /home/test/python390.chm dest: /home/test # 这个命令默认是使用本地的压缩文件，但是我们使用的是远程的压缩文件， # 所以，我们就需要设置remote_src这个参数 remote_src: yes Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 16:16:04 "},"ansible与云计算/docker与ansible.html":{"url":"ansible与云计算/docker与ansible.html","title":"docker与ansible","keywords":"","body":"原因 Ansible可以在两个方面简化Docker的工作。 其一就是Docker容器的编排。当你部署一 个“Docker化”的软件应用时，通常会创建多个Docker容器，并且容器内运行着不同的服 务。这些服务需要互相进行通信，因此你需要让容器按需互联，并且确保它们按照正确的 顺序启动。起初，Docker项目并没有提供编排工具，因此出现了一些第三方工具来填补这 个缺口。Ansible就是为编排而编写的，因此它天然适合部署基于Docker的应用。 另一个方面是创建Docker镜像,当开始创建更复杂镜像的时候，你马上就会想念Ansible提供的强大功能了。幸运 的是，你是可以使用Ansible的。 如何联系 在本地主机上创建Docker镜像。 将Docker镜像从本地主机推送到镜像仓库。 将Docker镜像从镜像仓库中下载到远程主机 在远程主机上启动Docker容器，在容器启动的时候将所需的配置信息传给它。 在Ansible 2.1发布时，Ansible项目发布了一个叫Ansible Container的工具，用于简化 Docker镜像和容器的相关工作。Ansible Container从Conductor容器中挂载含有Python运行时和相关库的目录到正在配 置的容器中。具体操作是，挂载Conductor容器中的/usr到正在配置容器的/_usr目录，配置 Ansible使用/_usr下面的Python解释器。 创建Docker镜像 下面我们使用Ansible Container创建Nginx镜像，进行相关操作 初始化命令 ansible-container init 这个命令会在当前目录下面创建这些文件 |---ansible-requirements.txt |---ansible.cfg |---container.yml |---requirementes.yml 创建role 我们需要一个配置容器的role。我们的role叫作ghost-nginx，因为它配置了一 个放在Ghost前面的Nginx镜像. task/main.yml 文件内容 --- - name: remove default config file: path: /etc/nginx/conf.d/default.conf state: absent - name: add ghost config copy: src: ghost.conf dest: /etc/nginx/conf.d/ghost.conf 配置 container.yml 这个文件也就是我们的playbook 类似于Docker Compose文件，不同的是它带有一些Ansible特有的字段，支持Jinja2风格的 变量，用于替换和过滤。 version: \"2\" #Ansible Container支持Docker Compose 版本2协议。 settings: conductor_base: debain:jessie # 使用debian:jessie作为Conductor容器的基础镜像 services: #service字段是一个映射，key是我们将要创建的容器的名字。中仅有一个容器。 ac-nginx: # 我们为将要创建的容器起名为ac-nginx from: nginx # 指定nginx作为基础镜像。 command: [nginx, -g,daemon off;]# 指定容器启动时需要运行的命令。 roles: # 指定用于配置镜像的role。本例仅有一个role,ghost-nginx。 - ghost-nginx registries:{}# registries字段用于指定其他外部registry。我们没有配置它，留空。 Ansible Container 不会将基础镜像自动拉取到本地，你必须在构建容器之前手动拉取基础镜像 docker pull nginx 构建镜像 ansible-container build 本地运行 version: \"2\" settings: conductor_base: debain:jessie services: ac-nginx: from: nginx command: [nginx, -g,daemon off;] roles: role,ghost-nginx。 - ghost-nginx ports: - \"8443:443\" - \"8000:80\" dev_overrides:# 在该区段中包含本地运行的内容 volumns: - $PWD/certs:/certs links: - ghost ghost: from: ghost dev_overrides: volumns: - $PWD/ghostdata:/var/lib/ghost registries:{} 可以使用如下命令启动本地机器上的容器： $ ansible-container 可以使用如下命令停止它们： $ ansible-container stop 如果想停止所有的容器并删除你创建的所有镜像，可使用如下命令： $ ansible-container destroy 发布镜像到registry 需要配置container.yml中的registries区段指定一个registry。 第一次推送镜像的时候，需要指定用户名作为命令行参数： ansible-container push--username $YOUR_USERNAME 将容器部署到生产环境 TODO Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 02:14:00 "},"ansible与云计算/ec2与ansible.html":{"url":"ansible与云计算/ec2与ansible.html","title":"ec2与ansible","keywords":"","body":"认证 与ec2进行交互的时候，需要指定认证依据，与ec2 api进行交互的时候，我们需要用到access key ID和secret access key。 环境变量 将access key ID和secret access key配置到环境变量中 export AWS_ACCESS_KEY_ID=... export AWS_SECRET_ACCESS_KEY=... 配置文件 要想使用Ansible 所有关于EC2 的功能，需要在控制主机上安装Python Boto 类库。ansible是通过这个库与ec2进行所有功能的交互，所以只要配置好这个库，即可。 Boto配置文件是文本文件，其格式类似于.ini配置文件，该文件为控制Boto库行为的选项指定值。在Unix / Linux系统中，启动时，boto库将在以下位置按以下顺序查找配置文件： /etc/boto.cfg - for site-wide settings that all users on this machine will use (if profile is given) ~/.aws/credentials - for credentials shared between SDKs (if profile is given) ~/.boto - for user-specific settings ~/.aws/credentials - for credentials shared between SDKs ~/.boto - for user-specific settings boto配置文件可能如下所示： [Credentials] aws_access_key_id = aws_secret_access_key = 配置ansible.cfg 配置ansible.cfg 支持使用EC2. 当使用Ansible来配置EC2实例时，我在ansible.cfg里面添加了下面几行代码： [defaults] remote_user=ubuntu host_key_checking=False 含义： 在这些镜像中你应该使用ubuntu用户来进行SSH 操 作。 关闭了主机密钥检查，因为我无法事先知道新实例上的主机密钥是什么。 启动新的实例 - name: start an instance with the packered ami hosts: localhost gather_facts: False tasks: - name: start a xenial instance from a known ami ec2: region: us-west-1 image: ami-79df8219 # 参数表示Amazon 系统镜像（AMI）的ID instance_type: t2.micro # 实例类型 key_name: mykey group: [web, ssh, outbound] # 参数表示与实例关联的安全组列表。 instance_tags: #用EC2 的键值对标签的方式将元数据和实例关联在一起 Name: packer test register: result - debug: var=result 获得最新的AMi Ansible 附带了一个名为ec2_ami_find的模块，该模块将根据搜索条件（如镜像名称或 者标签）检索AMI列表。 - name: find xenial image hosts: localhost gather_facts: False tasks: - name: find the image ec2_ami_find: name: \"ubuntu/images/ebs-ssd/ubuntu-xenial-16.04-amd64-server-*\" sort: name sort_order: descending sort_end: 1 no_result_action: fail register: ami - name: output image info debug: var=ami 镜像的名称 总是以时间戳结束,ec2_ami_find模块的name选项允许使用*作为通配符，所以我们获取最新镜像的方法 是按照名称倒序排序的，并限制只搜索一个项目。 EC2 密钥对 创建新的密钥 Amazon 不会保存私钥的副本，因此你需要在生成之后保存好它。 - name: make a keypair hosts: localhost gather_facts: False tasks: - name: create mykey ec2_key: name=mykey region=us-west-1 register: keypair - name: write the key to a file copy: dest: files/mykey.pem content: \"\" mode: 0600 when: keypair.changed # 只有状态被改变了，说明生成了新的密钥，保存密钥 - name: dump var debug: var=keypair 上传已有密钥 安全组 在使用它们之 前用ec2_group模块来确认这些安全组是否已经被创建。 - name: create security groups hosts: localhost gather_facts: False vars: region: us-west-1 tasks: - name: web security group ec2_group: region: \"\" name: web description: allow http and https access rules: - proto: tcp from_port: 80 to_port: 80 cidr_ip: 0.0.0.0/0 - proto: tcp from_port: 443 to_port: 443 cidr_ip: 0.0.0.0/0 - name: ssh security group ec2_group: region: \"\" name: ssh description: allow ssh access rules: - proto: tcp from_port: 22 # 允许的端口起始端口 to_port: 22 # 允许的端口终止端口 cidr_ip: 0.0.0.0/0 # 允许连接的子网ip地址，使用CIDR表示法 - name: outbound group ec2_group: region: \"\" name: outbound description: allow outbound connections to the internet rules_egress: - proto: all cidr_ip: 0.0.0.0/0 将ec2加入到群组中。 TODO 等待服务器启动 能在提交了创建EC2 实例的请求后不能立刻对它执行playbook。因为势力创建需要花费一点时间 - name: START THE INSTANCE ec2: region: us-west-1 image: ami-79df8219 # 参数表示Amazon 系统镜像（AMI）的ID instance_type: t2.micro # 实例类型 key_name: mykey group: [web, ssh, outbound] # 参数表示与实例关联的安全组列表。 instance_tags: #用EC2 的键值对标签的方式将元数据和实例关联在一起 Name: packer test wait: yes register:ec2 - name: wait for ssh server to be running wait_for: host= with_items: \"\" wait_for的调用过程使用了search_regex参数在连接到主机之后查找OpenSSH 字符串。因此在创建实例task之后放上这个task，可以有效进行同步，保证全部实例被创建好之后，才继续执行。 完整的流程 下面总结一下，上面的步骤，整合成一个完整的yaml。从创建ec2实例开始 --- - name: launch webservers hosts: localhost vars: region: us-west-1 instance_type: t2.micro count: 1 tasks: - name: ec2 keypair ec2_key: \"name=mykey key_material= region=\" with_file: ~/.ssh/id_rsa.pub - name: web security group ec2_group: name: web description: allow http and https access region: \"\" rules: - proto: tcp from_port: 80 to_port: 80 cidr_ip: 0.0.0.0/0 - proto: tcp from_port: 443 to_port: 443 cidr_ip: 0.0.0.0/0 - name: ssh security group ec2_group: name: ssh description: allow ssh access region: \"\" rules: - proto: tcp from_port: 22 to_port: 22 cidr_ip: 0.0.0.0/0 - name: outbound security group ec2_group: name: outbound description: allow outbound connections to the internet region: \"\" rules_egress: - proto: all cidr_ip: 0.0.0.0/0 - name: Get the ubuntu xenial ebs ssd AMI ec2_ami_find: name: \"ubuntu/images/hvm-ssd/ubuntu-xenial-16.04-amd64-server-*\" region: \"\" sort: name sort_order: descending sort_end: 1 no_result_action: fail register: ubuntu_image - set_fact: \"ami=\" - name: start the instances ec2: region: \"\" image: \"\" instance_type: \"\" key_name: mykey group: [web, ssh, outbound] instance_tags: { Name: ansiblebook, type: web, env: production } exact_count: \"\" count_tag: { type: web } wait: yes register: ec2 - name: add the instance to web and production groups add_host: hostname= groups=web,production with_items: \"\" when: item.public_dns_name is defined - name: wait for ssh server to be running wait_for: host= port=22 search_regex=OpenSSH with_items: \"\" when: item.public_dns_name is defined - name: configure webservers hosts: web:&production become: True gather_facts: False vars: ansible_python_interpreter: /usr/bin/python2.7 pre_tasks: - name: install python raw: apt-get install -y python2.7 roles: - web vpc 虚拟加密云，这个其实就相当于将数据中心搬到了云上。可以完全掌控vpc，包括自有ip范围划分、划分网段、配置路由表和网关等也可以通过vpn等连接方式将vpc与传统数据中心组合成一个按需定制的网络环境，实现应用的平滑迁移。 vpc特点： 完全隔离，使用隧道技术达到与传统vlan相同隔离效果的广播或者隔离在实例网卡应用。 软件定义网络，管理实时生效。 应用场景 资源扩展 独立vpc 混合云 ansible构建vpc 创建带有Internet路由表的两个子网的VPC。 --- - name: create vpc hosts: localhost gather_facts: False vars: region: us-west-1 tasks: - name: create a vpc ec2_vpc_net: region: \"\" name: \"Book example\" cidr_block: 10.0.0.0/16 tags: env: production register: result - set_fact: \"vpc_id=\" - name: add gateway ec2_vpc_igw: region: \"\" vpc_id: \"\" - name: create web subnet ec2_vpc_subnet: region: \"\" vpc_id: \"\" cidr: 10.0.0.0/24 tags: env: production tier: web - name: create db subnet ec2_vpc_subnet: region: \"\" vpc_id: \"\" cidr: 10.0.1.0/24 tags: env: production tier: db - name: set routes ec2_vpc_route_table: region: \"\" vpc_id: \"\" tags: purpose: permit-outbound subnets: - 10.0.0.0/24 - 10.0.1.0/24 routes: - dest: 0.0.0.0/0 gateway_id: igw 构建AMI 使用ec2 ami模块使用ec2 ami模块 ec2_ami模块会为一个正在运行的实例创建快照并将其保存成一个AMI。例14-16 列出 了一个此模块的实践案例。 - name: create am AMI hosts: localhost vars: instance_id: i-e5bfc26641f1b918 tasks: - name: create the AMI ec2-ami: description: Ubuntu16.64 with nginx installed instance_id: \"\" wait: yes register:ami - name: ouput ami details deug: var=ami 上面是为一个实例创建一个快照 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 11:42:28 "},"回调插件/01回调插件的使用.html":{"url":"回调插件/01回调插件的使用.html","title":"01回调插件的使用","keywords":"","body":"回调插件类型 回调插件类型在回调插件类中定义： class CallbackModule(CallbackBase): CALLBACK_TYPE = 'notification' 不同的回调类型对于 playbook 的输出有不⼀样的效果 stdout 标准输出类型，⽤在回调的主管理者 aggregate 聚合类型， 把此类型插件处理的结果和 stdout 类型插件合并⼀起输出到标准输出。⽐如 : timer， profile_tasks 等。 notification 通知类型，不参与标准输出，也不影响标准输 出插件的正常输出，只是会把执⾏ playbook 的返回值写的指 定的媒介中。 ⽐如： log_plays，mail。假如⾃定义把执⾏playbook 的结 果输出到数据库中就可以使⽤此类型。 查看插件类型 # 插件存放地方 /usr/lib/python2.7/site-packages/ansible/plugins/callback/* 启动回调插件 回调管理者 同时只能有⼀个回调插件作为主要的管理者，⽤于输出到屏幕。 如果想替换，应该在这个插件中修改 CALLBACK_TYPE = stdout， [defaults] stdout_callback = json # 以 JSON 的格式输出结果 或使⽤⾃定义的回调： [defaults] stdout_callback = mycallback 启⽤其他内置的回调插件 ⼤部分情况下，⽆论是内置的回调插件还是⾃定义的回调插件，都 需要在 ansible.cfg 中添加到⽩名单中，从⽽才能启⽤。 callback_whitelist = timer, mail, profile_roles,custom_callback timer 这个回调插件可以计算整个 playbook 的运⾏时间 mail 这个回调插件可以实现发送邮件的功能 profile_roles 这个插件是在执⾏中提添加⽤时时间 custom_callback 是⾃定义的插件 把返回结果输出到⽇志中 内置的回调插件 log_plays 会将 playbook 的返回信息输出到/var/log/ansible/hosts ⽬录中。 首先，配置⽇志存放的⽬录,ansible.cfg ⽂件的最后添加如下配置 [callback_log_plays] log_folder=/tmp/ansible/hosts/ 配置到⽩名单 [default] ... callback_whitelist = log_plays Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 14:04:54 "},"回调插件/02日志回调插件源码解析.html":{"url":"回调插件/02日志回调插件源码解析.html","title":"02日志回调插件源码解析","keywords":"","body":"# (C) 2012, Michael DeHaan, # (c) 2017 Ansible Project # GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt) # 兼容py2与py3 from __future__ import (absolute_import, division, print_function) __metaclass__ = type # 定义了一个元类 # 描述文件的信息，经过yaml解析从而可以被各种参数解析输出 DOCUMENTATION = ''' callback: log_plays type: notification short_description: write playbook output to log file version_added: historical description: - This callback writes playbook output to a file per host in the `/var/log/ansible/hosts` directory requirements: - Whitelist in configuration - A writeable /var/log/ansible/hosts directory by the user executing Ansible on the controller options: log_folder: version_added: '2.9' default: /var/log/ansible/hosts description: The folder where log files will be created. env: - name: ANSIBLE_LOG_FOLDER ini: - section: callback_log_plays key: log_folder ''' import os import time import json # 创建文件夹 from ansible.utils.path import makedirs_safe from ansible.module_utils._text import to_bytes from ansible.module_utils.common._collections_compat import MutableMapping from ansible.parsing.ajson import AnsibleJSONEncoder # 所有的插件都要继承这个CallbackBase父类 from ansible.plugins.callback import CallbackBase # NOTE: in Ansible 1.2 or later general logging is available without # this plugin, just set ANSIBLE_LOG_PATH as an environment variable # or log_path in the DEFAULTS section of your ansible configuration # file. This callback is an example of per hosts logging for those # that want it. ''' 继承：可以继承父的一些方法 重写：外壳不变，核心重写 重构: ''' class CallbackModule(CallbackBase): \"\"\" logs playbook results, per host, in /var/log/ansible/hosts \"\"\" CALLBACK_VERSION = 2.0 CALLBACK_TYPE = 'notification' CALLBACK_NAME = 'log_plays' CALLBACK_NEEDS_WHITELIST = True TIME_FORMAT = \"%b %d %Y %H:%M:%S\" MSG_FORMAT = \"%(now)s - %(category)s - %(data)s\\n\\n\" def __init__(self): super(CallbackModule, self).__init__() def set_options(self, task_keys=None, var_options=None, direct=None): ''' 内部会自动调用这个函数 ''' super(CallbackModule, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct) self.log_folder = self.get_option(\"log_folder\") # 从配置文件中获取log文件的路径 if not os.path.exists(self.log_folder): # 如果路径不存在，那么就回去创建一个安全路径 makedirs_safe(self.log_folder) # 自己写的逻辑函数 def log(self, host, category, data): ''' 用于记录日志，其中host就是被执行任务的主机。每次都死执行一个， 就是inventory文件中的一个主机 ''' if isinstance(data, MutableMapping): if '_ansible_verbose_override' in data: # avoid logging extraneous data data = 'omitted' else: data = data.copy() invocation = data.pop('invocation', None) data = json.dumps(data, cls=AnsibleJSONEncoder) if invocation is not None: data = json.dumps(invocation) + \" => %s \" % data path = os.path.join(self.log_folder, host) now = time.strftime(self.TIME_FORMAT, time.localtime()) msg = to_bytes(self.MSG_FORMAT % dict(now=now, category=category, data=data)) with open(path, \"ab\") as fd: fd.write(msg) # # 以下这些犯法是父类中的方法，ansible会自动去调用这些方法。 # 写回调插件，其实也就是写这些方法 def runner_on_failed(self, host, res, ignore_errors=False): ''' 运行失败，调用一下记录日志的方法 ''' self.log(host, 'FAILED', res) def runner_on_ok(self, host, res): ''' 运行成功，调用一下记录日志的方法 ''' self.log(host, 'OK', res) def runner_on_skipped(self, host, item=None): ''' 运行跳过，调用一下记录日志的方法 ''' self.log(host, 'SKIPPED', '...') def runner_on_unreachable(self, host, res): ''' 不可达，调用一下记录日志的方法 ''' self.log(host, 'UNREACHABLE', res) def runner_on_async_failed(self, host, res, jid): ''' 异步失败，调用一下记录日志的方法 ''' self.log(host, 'ASYNC_FAILED', res) def playbook_on_import_for_host(self, host, imported_file): self.log(host, 'IMPORTED', imported_file) def playbook_on_not_import_for_host(self, host, missing_file): self.log(host, 'NOTIMPORTED', missing_file) # 下面就是支持的一些方法 # def set_play_context(self, play_context): # pass # def on_any(self, *args, **kwargs): # pass # def runner_on_failed(self, host, res, ignore_errors=False): # pass # def runner_on_ok(self, host, res): # pass # def runner_on_skipped(self, host, item=None): # pass # def runner_on_unreachable(self, host, res): # pass # def runner_on_no_hosts(self): # pass # def runner_on_async_poll(self, host, res, jid, clock): # pass # def runner_on_async_ok(self, host, res, jid): # pass # def runner_on_async_failed(self, host, res, jid): # pass # def playbook_on_start(self): # pass # def playbook_on_notify(self, host, handler): # pass # def playbook_on_no_hosts_matched(self): # pass # def playbook_on_no_hosts_remaining(self): # pass # def playbook_on_task_start(self, name, is_conditional): # pass # def playbook_on_vars_prompt(self, varname, private=True, prompt=None, encrypt=None, confirm=False, salt_size=None, salt=None, default=None, unsafe=None): # pass # def playbook_on_setup(self): # pass # def playbook_on_import_for_host(self, host, imported_file): # pass # def playbook_on_not_import_for_host(self, host, missing_file): # pass # def playbook_on_play_start(self, name): # pass # def playbook_on_stats(self, stats): # pass # def on_file_diff(self, host, diff): # pass # Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 11:54:16 "},"回调插件/ces.html":{"url":"回调插件/ces.html","title":"Ces","keywords":"","body":" ⽤Python编写 引发错误，就是遇到问题后，主动抛出异常 返回以unicode编码的字符串，主要是兼容 Jinja2 from ansible.module_utils._text import to_text result_string = to_text(result_string) 符合Ansible的配置和⽂档标准，就是可以通过 ansible.cfg 进⾏配置 Ansible的在线帮助⽂档是根据每个模块的源代码中的 DOCUMENTATION模块⽣成的。该DOCUMENTATION块必须是有效的 YAML。 DOCUMENTATION模块说明： DOCUMENTATION = ''' callback: log_plays type: notification short_description: write playbook output to log file version_added: historical description: - 此插件的详细描述信息。 - 使⽤多条⽬，不要使⽤⼀个较⻓的语句。 - 不应该提及模块名称。 requirements: - 必须要求清单 - 包括最低版本的限制 # 下面的option是这个插件需要进行的配置选项， # env是指环境变量中需要定义的 # ini这个是ansible.cfg中进行配置的选项section,指的是配置文件中的部分 # key指的是其中的配置，比如下面这个例子 # ini: # - section: callback_log_plays # key: log_folder # 在配置文件中就是这么表示 # [callback_log_plays] # log_folder=/tmp/ansible/hosts # 其中section就是 [callback_log_plays] # key就是 这个log_folder关键字 options: log_folder: version_added: '2.9' 此插件添加到 Ansible 时候的当时 Ansible 的版本。 default: 选项的默认值，如果 required 是 False,则 default 可以设置 description: 此选项的作⽤的详细说明。应该⽤完整的句⼦写成。 env: - name: 环境变量的名字 ini: - section: 在 asible.cfg 中的配置块名称key: log_folder在对应配置块下⾯的变量名称 key: name required: True/False 必需时为 True,如果不设置，就认为不是必须的。 type: int/str/list 不是必须的 要访问插件中的配置设置，请使 ⽤self.get_option(\"log_folder\")。 如果需要显式个配置选项设置值，请使⽤self.set_options() 代码编写： from __future__ import (absolute_import, division, print_function) __metaclass__ = type DOCUMENTATION = ''' callback: mysql_plays type: notification short_description: 将 playbook 的执⾏结果输出到MySQL 中。 version_added: historical description: - 这个回调插件将会把输出存⼊ MySQL 服务器中。 requirements: - 需要配置到 ansible.cfg 中 Whitelist - 可以被访问的 MySQL 服务器实例 - Python 版本对应的 pymysql 或者 mysqlclient 模块 options: mysql_host: version_added: '2.9' default: locallhost description: MySQL 服务器 IP或者主机名. env: - name: ANSIBLE_MYSQL_HOST ini: - section: callback_mysql_plays key: mysql_host mysql_port: version_added: '2.9' default: 3306 description: MySQL 服务器监听端⼝. env: - name: ANSIBLE_MYSQL_PORT ini: - section: callback_mysql_plays key: mysql_port type: int mysql_user: version_added: '2.9' default: ansible description: MySQL 服务器登录⽤户. env: - name: ANSIBLE_MYSQL_USER ini: - section: callback_mysql_plays key: mysql_user mysql_password: version_added: '2.9' default: 'QFedu123!' description: MySQL 服务器登录⽤户. env: - name: ANSIBLE_MYSQL_PASSWORD ini: - section: callback_mysql_plays key: mysql_password mysql_db: version_added: '2.9' default: ansible description: 存放数据的库名称. env: - name: ANSIBLE_MYSQL_DB ini: - section: callback_mysql_plays key: db mysql_table: version_added: '2.9' default: playsresult description: 存放数据的表名称. env: - name: ANSIBLE_MYSQL_TABLE ini: - section: callback_mysql_plays key: mysql_table ''' import json import getpass from ansible.module_utils.common._collections_compat import MutableMapping from ansible.parsing.ajson import AnsibleJSONEncoder from ansible.plugins.callback import CallbackBase from ansible.errors import AnsibleError from ansible.module_utils._text import to_native try: import pymysql as mysqldb pwd = \"password\" database = \"db\" except ImportError: try: import MySQLdb as mysqldb pwd = \"passwd\" database = \"database\" except ImportError: raise AnsibleError(\"找不到 pymysql 或mysqlclient 模块。\") class CallbackModule(CallbackBase): \"\"\" 把 playbook 的结果保存到 MySQL 数据库中，默认的库.表是 ansible.playsresult \"\"\" CALLBACK_VERSION = 2.0 CALLBACK_TYPE = 'notification' CALLBACK_NAME = 'mysql_plays' CALLBACK_NEEDS_WHITELIST = True TIME_FORMAT = \"%b %d %Y %H:%M:%S\" MSG_FORMAT = \"%(now)s - %(category)s - %(data)s\\n\\n\" def __init__(self): super(CallbackModule, self).__init__() def set_options(self, task_keys=None, var_options=None, direct=None): \"\"\" ⽤于设置选项和获取选项， 选项包含了⾃定义的选项 \"\"\" super(CallbackModule,self).set_options(task_keys=task_keys, var_options=var_options, direct=direct) self.mysql_host =self.get_option(\"mysql_host\") self.mysql_port =self.get_option(\"mysql_port\") self.mysql_user=self.get_option(\"mysql_user\") self.mysql_password =self.get_option(\"mysql_password\") self.mysql_db =self.get_option(\"mysql_db\") self.mysql_table =self.get_option(\"mysql_table\") self.user = getpass.getuser() def _mysql(self): \"\"\" 连接数据库，返回数据库对象和游标对象 \"\"\" db_conn={\"host\": self.mysql_host, \"port\": self.mysql_port, \"user\": self.mysql_user, pwd: self.mysql_password, database: self.mysql_db} try: db = mysqldb.connect(**db_conn) except Exception as e: raise AnsibleError(\"%s\" %to_native(e)) cursor= db.cursor() return db, cursor def _execute_sql(self, host, category, data): if isinstance(data, MutableMapping): if '_ansible_verbose_override' in data: # avoid save extraneous data data = 'omitted' else: data = data.copy() invocation =data.pop('invocation', None) data = json.dumps(data,cls=AnsibleJSONEncoder) if invocation is not None: data = json.dumps(invocation) + \" => %s \" % data sql = \"\"\" insert into {} (host,user,category,result) values(%s,%s,%s,%s) \"\"\".format(self.mysql_table) db, cursor = self._mysql() try: # 执⾏ sql，记录事件类型和事件结果 cursor.execute(sql, (host, self.user, category, data)) db.commit() except Exception as e: raise AnsibleError(\"%s\" % to_native(e)) finally: cursor.close() db.close() def runner_on_failed(self, host, res, ignore_errors=False): self._execute_sql(host, 'FAILED', res) def runner_on_ok(self, host, res): self._execute_sql(host, 'OK', res) def runner_on_skipped(self, host, item=None): self._execute_sql(host, 'SKIPPED', '...') def runner_on_unreachable(self, host, res): self._execute_sql(host, 'UNREACHABLE', res) def runner_on_async_failed(self, host, res, jid): self._execute_sql(host, 'ASYNC_FAILED', res) def playbook_on_import_for_host(self, host, imported_file): self._execute_sql(host, 'IMPORTED', imported_file) def playbook_on_not_import_for_host(self, host, missing_file): self._execute_sql(host, 'NOTIMPORTED', missing_file) 保存插件到有效的⽬录下 把插件保存为 mysql_plays.py ⽂件，并存到ansible 控制节点的 如下⽬录下: ~/.ansible/plugins/callback/ 开启使⽤插件 在 ansible.cfg 中编辑如下配置 callback_whitelist = mysql_plays 默认此插件仅对 playbook ⽣效，假如希望在 ad-hoc (快捷命令) 中⽣效，继续打开如下配置，并设置 True bin_ansible_callbacks = True 配置插件使⽤的选项 此插件已经有默认值，如果想修改需在 ansible.cfg ⽂件的最后添 加如下配置 [callback_mysql_plays] mysql_host = MySQL IP mysql_port = MySQL 监听端⼝ mysql_user = MySQL ⽤户 mysql_password = MySQL 密码 mysql_db = MySQL 库名 mysql_table = MySQL 表名 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 14:20:52 "},"ansible优化执行速度/Ansible的执⾏策略优化.html":{"url":"ansible优化执行速度/Ansible的执⾏策略优化.html","title":"Ansible的执⾏策略优化","keywords":"","body":"设置执行策略 默认的执⾏策略是按批并⾏处理的，假如总共 15 台主机，每次并 发 5 个线程执⾏的策略如下： h1/h2/h3/h4h5 | | | h6/h7/h8/h9/h10 | | | h11/h12/h13/h14/h15 全部执⾏完后，进⼊下⼀批 依次类推 从 asible2.0 开始，可以通过在 playbook 中设置 strategy 的值改 变这策略， 也可以在 ansible.cfg 配置⽂件中设置⼀个默认的策略: [defaults] strategy = free 或者在play-book中进行设置 - hosts: webservers strategy: free tasks: - name: ping hosts ping: 改变后的策略，可以前赴后继的对主机进⾏执⾏ task，执⾏模式 如下： h1/h2/h3/h4/h5 ------> h1/h2/h3/h6/h5 ------->h1/h2/h3/h6/h7 -----> 设置多个执行队列 默认 Ansible 的执⾏队列有⼀个，就是并⾏执⾏，假如控制节 点的机器有多个 CPU，并且性能较好，可以打开多个执⾏队列，就 是并发。 ⽅式⼀: 在 ansible.cfg 中设置 [defaults] forks = 30 ⽅式⼆： 在命令⾏⾥使⽤ ansible-playbook -f 3 my_playbook.yml Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 00:19:36 "},"ansible优化执行速度/ssh优化.html":{"url":"ansible优化执行速度/ssh优化.html","title":"ssh优化","keywords":"","body":"设置 SSH 为⻓连接 openssh5.6 版本后⽀持 Multiplexing 检查控制机器的 ssh 版本 [root@ansible-control command_module]# ssh -V OpenSSH_7.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017 设置 ansible 配置⽂件——ansible.cfg ssh_args = -C -o ControlMaster=auto -o ControlPersist=10d # ControlPersist=10d 表示保持⻓连接 10 天。 # 60s 是 60 秒 建⽴⻓连接并测试,设置好后，重新连接⼀次被控主机，即可让控制主机和被控主机之 间建⽴⻓连接 验证⻓连接 [root@ansible-control command_module]# ss -nta |grep ESTAB ESTAB 0 0 192.168.243.139:22 192.168.243.1:3224 ESTAB 0 0 192.168.243.139:22 192.168.243.1:3221 ESTAB 0 0 192.168.243.139:22 192.168.243.1:3225 输出中 有 ESTAB 状态的就代表是⻓连接，上文中有三台设备，目前处于长连接状态。 使用pipeline传输py文件 默认情况下 Ansible 执⾏过程中会把⽣成好的本地 python 脚本⽂件 PUT 到 远端机器。如果我们开启了 ssh 的 pipelining 特性，这个过程就会在 SSH 的会话中进⾏。 第一步，在 ansible.cfg 配置⽂件中设置 pipelining 为 True pipelining = True 第二步，在远程机子上禁用requiretty # Disable \"ssh hostname sudo \", because it will show the password in clear text. # You have to run \"ssh -t hostname sudo \". # # Defaults requiretty Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 18:57:34 "},"ansible优化执行速度/异步.html":{"url":"ansible优化执行速度/异步.html","title":"异步","keywords":"","body":"异步轮询机制 通过异步轮询机制，即将一个任务异步执行，定时轮询得到结果。通过异步模块获取到task的结果 有时候执行某个任务可能需要很长的时间，在集群规模较大的情况下慢得让人无法忍受。这时可以考虑使用异步模式。 在tasks里增加async的属性 设成某个数字，比如60，意思就是这个任务最大运行时间不能超过60秒。也可以设成0，意思是不管任务运行多久，一直等待即可。如果没有指定async，则默认为同步模式。 还可以设定poll，默认值为10，意思就是每隔10秒轮询查看结果。如果不需要查看结果，设为0就好了。还可以通过register和async_status设定暂时不查看结果，等需要的时候再查看。 注意的是： 不应通过将轮询值指定为0来进⾏需要排他锁的操作（例如yum事 务）来尝试异步运⾏任务。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-27 00:35:26 "},"ansible核心概念.html":{"url":"ansible核心概念.html","title":"ansible核心概念","keywords":"","body":"investory文件 管理节点的清单列表 可以按照组进行划分，将机子划分到不同的组中，比如web组和database组。这样子，在命令行中就可以直接通过管理组对这些组节点分块管理。 [web1] ... [web2] .. [database] play book 这个就是通过play book对不同的分组机器进行不同的task管理。 Role(web server) task(git) task(apache) Role(database) task(mysql) 这个playbook的作用就是对web组执行git和apache两个命令,而对database组执行mysql指令。 其中的task就是一个action，一个Role中可以有多个action model ansible通过源代码实现了很多的模块，而play book中就可以去进行调用这些model。 ansible官方手册 https://docs.ansible.com/ set_fact 关键字 task中的单位是单个主机。 逐台主机运行 Ansible并行地在所有涉及的主机上执行每一个task。有时候你希望逐台 主机来执行task。最典型的例子就是对负载均衡后面的应用服务器进行升级。通常来说， 你会将应用服务器从负载均衡上摘除，更新它，然后再添加回去。但是你肯定不希望将所 有应用服务器都从负载均衡上摘除，这会导致服务不可用。 使用serial语句对Ansible并行执行play的主机数量进行限制。 使用max_fail_percentage语句来指定Ansible在将整个play置为失败 之前的最大失败主机比例。 如果在负载均衡后面有四台主机，并且有一台主机执行task失败，那么Ansible还将继 续执行play，因为没有超过25%的阈值。然而，如果有第二台主机执行task失败，Ansible 将会让整个play失败。 - name: a host to run hosts: myhosts serial:1 tasks: ... 如果要，一次运行一批主机，那么只要将serial改成其他数字或者传入百分比也可以。 只执行一次 例如，也许有多台 应用服务器运行在负载均衡后面，你希望执行一个数据库迁移，但是你只需在一台应用服 务器上执行这个迁移。 - name: run the database migrations command: /opt/run_migrations run_once: true 对于每一个任务，Ansible都是在所有主机之间并行执行的。 在开始下一个任务之前，Ansible会等待所有主机都完成上一个任务。 所以，一个任务会被全部inventory主机执行完毕之后再去执行。在自由策略下 一个playbook中的三个任务，会被分成三步，每一步都要等全部主机执行完之后才能到下一步。并且执行每一步的时候是前仆后继的补充主机。 ansible比shell文件更好的点： Ansible对于模板有完美的支持，而且可以在各种位置中定义变 量。 playbook文件 每个play必须包含如下两项。 name 描述这个play的一段文字注释。Ansible将会在play开始运行的时候将这段文字打印出 来。 become 如果为真，Ansible会在运行每个任务的时候都切换为（默认）root用户。在管理 Ubuntu服务器的时候，这个配置会非常有用，因为Ubuntu默认不允许使用root用户进行 SSH登录。但是这个也有一个前提，那么就是这个用户具有sudo权限，否则就无法切换成功。 task执行 Ansible模块首先会在 采取任何行动之前检查主机的状态是否需要改变。如果主机的状态与模块的参数相匹配， 那么Ansible不会在这台主机上做任何操作并直接响应ok。 变量需要括号 - name host tasks: - 关于handler的几件需要记住的事情 handler只会在所有task执行完后执行。哪怕被通知了多次，它也只执行一次。 当play 中定义了多个handler时，handler按照play中定义的顺序执行，而不是通知的顺序。 handler唯一常见的用途是重启服务和重启机器。就我个人而 言，我仅用它重启服务。 提权 提权的前提，是用户在sudo组中·，如果不在就没法提权。 除了root用户，也可以切换到其他用户 become: True become_user: postgres 切换到postgres用户 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:28:54 "},"awx.html":{"url":"awx.html","title":"Awx","keywords":"","body":"相当于是为ansible 加上了restful api，这样子，我们就可以自己定制web去控制ansible。从而实现自动化运维。我们可以通过写web来与ansible 的restful api进行交互。 企业版就是ansible tower。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 13:20:34 "},"COLLECTION.html":{"url":"COLLECTION.html","title":"COLLECTION","keywords":"","body":"collection 是diy区，类似社区版库，上面有很多collection，而这个collection包括了module、role等。我们可以自己安装到本地，从而不需要等待官方去进行merge再发布新版本，降低了等待时间。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 11:41:38 "},"investory文件.html":{"url":"investory文件.html","title":"investory文件","keywords":"","body":"作用 就是记录资产，因为控制器需要控制多台节点，那么我们就需要把这些节点都放在同一个节点中。所以，我们可以在investory文件中定义我们的设备列表，然后通过ansible控制器去统一管理。 不用在每一台机子上都配一个ansible，control可以直接通过ssh去控制其他设备。 最简单的investory文件 ansible-node1 ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor 效果 [root@ansible-control ansible-code]# ansible ansible-node1 -m ping -i inventory.txt ansible-node1 | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 节点管理 我们可以通过all命令进行所有节点管理 也可以管理单一节点,使用ansible-node1这种资产名称访问单一节点 ansible-node1 ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor ansible-node2 ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor 也可以进行部分节点统一管理 [web1] ansible-node1 ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor ansible-node2 ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor 在上面这个文件中，如果我们使用 ansible web1 -m ping -i inventory.txt 那么我们就可以对ansible-node1和 ansible-node2进行统一管理。 通过正则匹配节点名称，进行管理 [web1] ansible-node[1:4] ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor 我们访问web1的时候，我们就会去访问控制四台节点机。 ansible目录结构 由两部分组成 ----site.yaml 作为playbook | ---investory文件 | -----project1 |---hosts文件 |---grouop_vars文件 |----host_vars文件 ------project2 |---hosts文件 |---grouop_vars文件 |----host_vars文件 选择不同的project，只要在ansible.cfg中指定hosts文件即可。 [defaults] investory = investory文件/projects/hosts文件 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-25 01:35:58 "},"yaml文件格式.html":{"url":"yaml文件格式.html","title":"yaml文件格式","keywords":"","body":"数据结构 对象 通过键值对，进行管理 name: value 注意点，value前面一定要有空格 字符串 字符串可以有双引号，也可以不需要双引号。 this is a string 'this is a string' \"this is a string\" # YAML 中若⼀⾏写不完你要表述的内容的时候，可以进⾏折⾏。写法如下: long_line: | Example 1 Example 2 Example 3 # 或者 long_line: > Example 1 Example 2 Example 3 数组 一组连词线开头的行，构成一个数组。 - Cat - Dog - Goldfish 注意点，连词后面要跟上空格。同时数组都是与对象进行嵌套,比如下面这个格式 languages: - Ruby - Perl - Python 字典格式 通过一组键值对组成的字典格式 YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 字典格式中的值也是有一个空格。同时字典一般与对象进行嵌套使用，如下文 websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 需要注意的是所有的嵌套都需要有一个空格 嵌套的话，数组和字典可以同时进行嵌套 companies: - id: 1 name: company1 price: 200W - id: 2 name: company2 price: 500W 等价于 companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}] companies: - host: web1 - host1: web2 等价于 companies:[{host:web1},{host1:web2}] 同一层只能由一种数据结构，比如说都是数组的结构 混合结构 class: - name: stu1 num: 001 - name: stu2 num: 002 - name: stu3 num: 003 # {'class': [{'name': 'stu1', 'num': 1}, {'name':'stu2', 'num': 2}, ... ]} 也可以如下 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 15:47:52 "},"杂记.html":{"url":"杂记.html","title":"杂记","keywords":"","body":"gather_facts 获取节点机的一些基本信息 目的就是可以在playbook配置文件中使用这些变量 - name: file module hosts: web1 tasks: - name: print gather_facts debug: msg: Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:31:14 "},"测试.html":{"url":"测试.html","title":"测试","keywords":"","body":"​ 迁移、迁移咨询、咨询 msp 耐克 底层EMR Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 01:34:42 "},"节点控制.html":{"url":"节点控制.html","title":"节点控制","keywords":"","body":"我们控制器，总是需要一个方法才能控制节点，与节点进行通信。下面介绍了几种方式 ssh密码形式 这种方式，通过将ssh密码写入investory文件，与节点进行通信 ansible-node1 ansible-connection=ssh ansible_user=root ansible_ssh_pass=toor 上面的ansible_ssh_pass就是密码 ssh key密钥访问节点 创建密钥 ssh-keygen 将公钥放置到节点中 ssh-copy-id -i ./ssh/id_rsa.pub ansible-node1 `./ssh/id_rsa.pub 产生的公钥 ansible-node1 指的是上传公钥的地址 现在已经成功的不需要密码就可以登陆到节点中。 investory文件内容中就可以不用写ansible_ssh_pass了。 [web1] ansible-node[1:4] ansible-connection=ssh ansible_user=root 输入命令的时候,带上private-key即可。 ansible web1 -m ping -i inventory.txt --private-key=/root/.ssh/id_rsa sdjsijd Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-26 13:22:06 "}}